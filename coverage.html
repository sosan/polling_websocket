
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>common: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">polling_websocket/pkg/common/random.go (87.5%)</option>
				
				<option value="file1">polling_websocket/pkg/config/clickhouse.go (0.0%)</option>
				
				<option value="file2">polling_websocket/pkg/config/envs.go (0.0%)</option>
				
				<option value="file3">polling_websocket/pkg/config/kafka.go (0.0%)</option>
				
				<option value="file4">polling_websocket/pkg/config/zitadel.go (0.0%)</option>
				
				<option value="file5">polling_websocket/pkg/domain/models/credentials.go (92.9%)</option>
				
				<option value="file6">polling_websocket/pkg/domain/models/customtime.go (50.0%)</option>
				
				<option value="file7">polling_websocket/pkg/domain/models/user.go (0.0%)</option>
				
				<option value="file8">polling_websocket/pkg/domain/services/auth.go (0.0%)</option>
				
				<option value="file9">polling_websocket/pkg/domain/services/polling.go (100.0%)</option>
				
				<option value="file10">polling_websocket/pkg/domain/services/pollingcontent.go (75.0%)</option>
				
				<option value="file11">polling_websocket/pkg/infra/brokerclient/credential.go (84.2%)</option>
				
				<option value="file12">polling_websocket/pkg/infra/brokerclient/kafkaclient.go (0.0%)</option>
				
				<option value="file13">polling_websocket/pkg/infra/brokerclient/polling.go (0.0%)</option>
				
				<option value="file14">polling_websocket/pkg/infra/httpclient/client.go (0.0%)</option>
				
				<option value="file15">polling_websocket/pkg/infra/httpclient/credential.go (92.5%)</option>
				
				<option value="file16">polling_websocket/pkg/infra/httpclient/polling.go (87.5%)</option>
				
				<option value="file17">polling_websocket/pkg/infra/httpclient/zitedel.go (0.0%)</option>
				
				<option value="file18">polling_websocket/pkg/infra/redisclient/polling.go (0.0%)</option>
				
				<option value="file19">polling_websocket/pkg/infra/redisclient/redisclient.go (0.0%)</option>
				
				<option value="file20">polling_websocket/pkg/infra/tokenrepo/token.go (0.0%)</option>
				
				<option value="file21">polling_websocket/pkg/vaults/setup_vaults.go (0.0%)</option>
				
				<option value="file22">polling_websocket/pkg/vaults/vault_redis.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package common

import (
        "crypto/rand"
        "math"
        "math/big"
        "time"
)

func RandomDuration(max, min time.Duration, attempt int) time.Duration <span class="cov10" title="2">{
        baseWait := min * time.Duration(math.Pow(2, float64(attempt)))

        jitterRange := int64(max - min)
        jitterBig, err := rand.Int(rand.Reader, big.NewInt(jitterRange))
        if err != nil </span><span class="cov0" title="0">{
                return baseWait
        }</span>

        <span class="cov10" title="2">jitter := time.Duration(jitterBig.Int64()) + min

        waitTime := baseWait + jitter

        return waitTime</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

type EnvClickhouseConfig struct{}

type ClickhouseConfig interface {
        GetClickhouseURI() string
        GetClickhouseToken() string
        GetEnv(key, fallback string) string
}

func (e *EnvClickhouseConfig) GetClickhouseURI() string <span class="cov0" title="0">{
        return GetEnv("CLICKHOUSE_API_URI", "")
}</span>

func (e *EnvClickhouseConfig) GetClickhouseToken() string <span class="cov0" title="0">{
        return GetEnv("CLICKHOUSE_TOKEN_PIPES", "")
}</span>

func (e *EnvClickhouseConfig) GetEnv(key, fallback string) string <span class="cov0" title="0">{
        return GetEnv(key, fallback)
}</span>

func NewClickhouseEnvConfig() ClickhouseConfig <span class="cov0" title="0">{
        return &amp;EnvClickhouseConfig{}
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "os"
        "path/filepath"
        "polling_websocket/pkg/vaults"

        "github.com/joho/godotenv"
)

func LoadEnvs(baseDir string) <span class="cov0" title="0">{
        if err := loadCurrentEnv(); err != nil </span><span class="cov0" title="0">{
                // log.Printf("WARNING | Cannot read current .env: %v", err)
                if err := loadBaseEnv(baseDir, ".env"); err != nil </span><span class="cov0" title="0">{
                        // log.Printf("WARNING | Cannot read base .env: %v", err)
                        _ = loadBaseEnv(baseDir, ".env.local")
                        // if err := loadBaseEnv(baseDir, ".env.local"); err != nil {
                        //        log.Printf("WARNING | Cannot read local .env.local: %v", err)
                        // }
                }</span>
        }

        // Load environment variables from Vault
        <span class="cov0" title="0">LoadEnvsFromVault()</span>
}

func loadCurrentEnv() error <span class="cov0" title="0">{
        return godotenv.Load()
}</span>

func loadBaseEnv(baseDir string, fileName string) error <span class="cov0" title="0">{
        envPath := filepath.Join(baseDir, fileName)
        return loadEnvFile(envPath)
}</span>

func loadEnvFile(envFilePath string) error <span class="cov0" title="0">{
        if _, err := os.Stat(envFilePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return godotenv.Load(envFilePath)</span>
}

func LoadEnvsFromVault() <span class="cov0" title="0">{
        vaults.GetEnvsFromVault()
}</span>

func GetEnv(key, fallback string) string <span class="cov0" title="0">{
        if value, exist := os.LookupEnv(key); exist </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return fallback</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

type EnvKafkaConfig struct{}

type KafkaConfig interface {
        GetServersURI() string
        GetProtocol() string
        GetMechanisms() string
        GetUsername() string
        GetPassword() string
        GetTimeout() string
        GetEnv(key, fallback string) string
}

func (e *EnvKafkaConfig) GetServersURI() string <span class="cov0" title="0">{
        return GetEnv("bootstrap.servers", "localhost:9092")
}</span>

func (e *EnvKafkaConfig) GetProtocol() string <span class="cov0" title="0">{
        return GetEnv("security.protocol", "SASL_SSL")
}</span>

func (e *EnvKafkaConfig) GetMechanisms() string <span class="cov0" title="0">{
        return GetEnv("sasl.mechanisms", "PLAIN")
}</span>

func (e *EnvKafkaConfig) GetUsername() string <span class="cov0" title="0">{
        return GetEnv("sasl.username", "")
}</span>

func (e *EnvKafkaConfig) GetPassword() string <span class="cov0" title="0">{
        return GetEnv("sasl.password", "")
}</span>

func (e *EnvKafkaConfig) GetTimeout() string <span class="cov0" title="0">{
        return GetEnv("session.timeout.ms", "45000")
}</span>

func (e *EnvKafkaConfig) GetEnv(key, fallback string) string <span class="cov0" title="0">{
        return GetEnv(key, fallback)
}</span>

func NewKafkaEnvConfig() KafkaConfig <span class="cov0" title="0">{
        return &amp;EnvKafkaConfig{}
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

type EnvZitadelConfig struct{}

type ZitadelConfig interface {
        GetZitadelURI() string
        GetZitadelServiceUserID() string
        GetZitadelServiceUserKeyPrivate() string
        GetZitadelServiceUserKeyID() string
        GetZitadelServiceUserClientID() string
        GetZitadelBackendID() string
        GetZitadelBackendKeyPrivate() string
        GetZitadelBackendKeyID() string
        GetZitadelKeyClientID() string
        GetZitadelProjectID() string
        GetZitadelBackendClientID() string
        GetEnv(key, fallback string) string
}

func (e *EnvZitadelConfig) GetZitadelURI() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_URI", "")
}</span>

func (e *EnvZitadelConfig) GetZitadelProjectID() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_PROJECTID", "")
}</span>

func (e *EnvZitadelConfig) GetZitadelKeyClientID() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_KEY_CLIENTID", "")
}</span>

func (e *EnvZitadelConfig) GetZitadelBackendClientID() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_KEY_CLIENTID", "")
}</span>

func (e *EnvZitadelConfig) GetZitadelServiceUserID() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_KEY_USERID_SERVICE_ACCOUNT", "")
}</span>

func (e *EnvZitadelConfig) GetZitadelServiceUserKeyPrivate() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_KEY_PRIVATE_SERVICE_ACCOUNT", "")
}</span>

func (e *EnvZitadelConfig) GetZitadelServiceUserKeyID() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_KEY_KEYID_SERVICE_ACCOUNT", "")
}</span>

func (e *EnvZitadelConfig) GetZitadelServiceUserClientID() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_KEY_CLIENTID_SERVICE_ACCOUNT", "")
}</span>

func (e *EnvZitadelConfig) GetEnv(key, fallback string) string <span class="cov0" title="0">{
        return GetEnv(key, fallback)
}</span>

func (e *EnvZitadelConfig) GetZitadelBackendID() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_KEY_APP_ID_BACKEND", "")
}</span>

func (e *EnvZitadelConfig) GetZitadelBackendKeyPrivate() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_KEY_PRIVATE_BACKEND", "")
}</span>

func (e *EnvZitadelConfig) GetZitadelBackendKeyID() string <span class="cov0" title="0">{
        return GetEnv("ZITADEL_KEY_KEYID_BACKEND", "")
}</span>

func NewZitaldelEnvConfig() ZitadelConfig <span class="cov0" title="0">{
        return &amp;EnvZitadelConfig{}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "encoding/json"
        "strings"
        "time"
)

// maybe repeated data
const (
        CredNameRequired          = "Credentials name is required"
        CredNameInvalid           = "Credentials name must be alphanumeric with max length of 255"
        CredNameExist             = "Credentials name already exists for this user"
        CredNameNotExist          = "Credentials name not exists for this user"
        CredNameCannotGenerate    = "error checking Credential name existence"
        CredNameNotGenerate       = "cannot create new Credential"
        CredDirectorySaveRequired = "Directory to save is required"
        CredDirectoryInvalid      = "Directory to save must be alphanumeric with max length of 255"
        CredDateInvalid           = "Invalid date"
        CredRateLimitUpdate       = 10 * time.Second
        UserTokenExpired          = "token expired"
        CredentialTopicName       = "credentials.command"
)

type RequestExchangeCredential struct {
        RevokedAt  *CustomTime    `json:"revoked_at,omitempty"`
        LastUsedAt *CustomTime    `json:"last_used_at,omitempty"`
        ExpiresAt  *CustomTime    `json:"expires_at,omitempty"`
        UpdatedAt  *CustomTime    `json:"updated_at,omitempty"`
        CreatedAt  *CustomTime    `json:"created_at,omitempty"`
        NodeID     string         `json:"nodeid,omitempty"`
        Sub        string         `json:"sub,omitempty"`
        WorkflowID string         `json:"workflowid,omitempty"`
        ID         string         `json:"id,omitempty" `
        Type       string         `json:"type,omitempty"`
        Name       string         `json:"name,omitempty"`
        Data       DataCredential `json:"data,omitempty"`
        Version    uint32         `json:"version,omitempty"`
        IsActive   bool           `json:"is_active,omitempty"`
}

type RequestCreateCredential struct {
        ID         string         `json:"id,omitempty"`
        Sub        string         `json:"sub,omitempty"`
        Name       string         `json:"name,omitempty" `
        Type       string         `json:"type,omitempty" `
        WorkflowID string         `json:"workflowid,omitempty"`
        NodeID     string         `json:"nodeid,omitempty"`
        Data       DataCredential `json:"data" binding:"required"`
        Timestamp  int64          `json:"timestamp,omitempty"`
}

type DataCredential struct {
        ID           string   `json:"id,omitempty"`
        ClientID     string   `json:"clientId"`
        ClientSecret string   `json:"clientSecret" `
        RedirectURL  string   `json:"redirectURL" `
        OAuthURL     string   `json:"oauthurl,omitempty"`
        State        string   `json:"state,omitempty"`
        Code         string   `json:"code"`
        CodeVerifier string   `json:"codeverifier"`
        Token        string   `json:"token,omitempty"`
        TokenRefresh string   `json:"tokenrefresh,omitempty"`
        Scopes       []string `json:"scopes,omitempty"`
}

type ResponseCreateCredential struct {
        Data   string `json:"data"`
        Error  string `json:"error"`
        Status int    `json:"status"`
}

type ResponseGetCredential struct {
        Credentials *[]RequestExchangeCredential `json:"credentials"`
        Error       string                       `json:"error"`
        Status      int                          `json:"status"`
}

type CredentialPayload struct {
        Data string `json:"data,omitempty"`
        RequestExchangeCredential
}

type InfoCredentials struct {
        Data                   *[]RequestExchangeCredential `json:"data,omitempty"`
        Rows                   *int64                       `json:"rows,omitempty"`
        RowsBeforeLimitAtLeast *int64                       `json:"rows_before_limit_at_least,omitempty"`
        Statistics             *Statistics                  `json:"statistics,omitempty"`
        Meta                   []Meta                       `json:"meta,omitempty"`
}

type Meta struct {
        Name *string `json:"name,omitempty"`
        Type *string `json:"type,omitempty"`
}

type Statistics struct {
        Elapsed   *float64 `json:"elapsed,omitempty"`
        RowsRead  *int64   `json:"rows_read,omitempty"`
        BytesRead *int64   `json:"bytes_read,omitempty"`
}

func (dc *RequestExchangeCredential) UnmarshalJSON(data []byte) error <span class="cov10" title="8">{
        type Alias RequestExchangeCredential
        aux := &amp;struct {
                *Alias
                Data json.RawMessage `json:"data"`
        }{
                Alias: (*Alias)(dc),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="8">cleanedData := cleanEscapedJSON(string(aux.Data))
        var dataCredential DataCredential
        if err := json.Unmarshal([]byte(cleanedData), &amp;dataCredential); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="7">dc.Data = dataCredential

        return nil</span>
}

func cleanEscapedJSON(escapedJSON string) string <span class="cov10" title="8">{
        cleaned := strings.Trim(escapedJSON, "\"")
        cleaned = strings.ReplaceAll(cleaned, "\\\"", "\"")
        cleaned = strings.ReplaceAll(cleaned, "\\\\", "\\")
        return cleaned
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import (
        "log"
        "time"
)

type CustomTime struct {
        time.Time
}

func (ct *CustomTime) UnmarshalJSON(b []byte) error <span class="cov10" title="3">{
        s := string(b)
        if s == "null" || s == `""` || s == `"0001-01-01T00:00:00Z"` || s == "1970-01-01 00:00:00" || s == "\"1970-01-01 00:00:00\"" </span><span class="cov0" title="0">{
                *ct = CustomTime{Time: time.Time{}}
                return nil
        }</span>

        <span class="cov10" title="3">s = s[1 : len(s)-1]
        parsedTime, err := time.Parse(time.RFC3339, s)
        if err != nil </span><span class="cov0" title="0">{
                parsedTime, err = time.Parse(time.DateTime, s)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("ERROR | Cannot parse time: %v", err)
                        *ct = CustomTime{Time: time.Time{}}
                        return nil
                }</span>
        }

        <span class="cov10" title="3">ct.Time = parsedTime
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "fmt"
)

type UserStatus uint8
type UserRoleID uint8

const (
        StatusActive  UserStatus = 1
        StatusInvited UserStatus = 2
        StatusPending UserStatus = 3
        StatusBlocked UserStatus = 4

        RoleAdmin     UserRoleID = 1
        RoleUser      UserRoleID = 2
        RoleModerator UserRoleID = 3
        RoleEditor    UserRoleID = 4
        RoleGuest     UserRoleID = 5
        RoleCustomer  UserRoleID = 6
        RoleSupport   UserRoleID = 7
        RoleManager   UserRoleID = 8
        RoleAnalyst   UserRoleID = 9
        RoleDeveloper UserRoleID = 10

        InvalidJSON = "Invalid JSON data"

        UserSubExist           = "Sub already exists"
        UserSubIsRequired      = "Sub is required"
        UserNameExist          = "username already exists"
        UserCannotGenerate     = "error checking Sub existence"
        UserNameCannotCreate   = "error checking username existence"
        UsertNameNotGenerate   = "cannot create new user"
        UserSubInvalid         = "Sub must be a numeric string with max length of 50"
        UserAccessTokenInvalid = "Access token must be a valid JWT with max length of 1000"
        UserSubRequired        = "Sub user is required"
        UserSubMustBe          = "Sub user must greater than 3 characters"
        UserInvalidStatus      = "Invalid status"
        UserInvalidRole        = "Invalid role ID"
        AuthInvalid            = "Authorization header is required"
)

func (s UserStatus) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StatusActive:<span class="cov0" title="0">
                return "active"</span>
        case StatusInvited:<span class="cov0" title="0">
                return "invited"</span>
        case StatusPending:<span class="cov0" title="0">
                return "pending"</span>
        case StatusBlocked:<span class="cov0" title="0">
                return "blocked"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

func UserStatusFromUint8(v uint8) (UserStatus, error) <span class="cov0" title="0">{
        if v &gt;= 1 &amp;&amp; v &lt;= 4 </span><span class="cov0" title="0">{
                return UserStatus(v), nil
        }</span>
        <span class="cov0" title="0">return 0, fmt.Errorf("invalid user status value: %d", v)</span>
}

type SyncUserResponse struct {
        Error   string `json:"error"`
        Status  int    `json:"status"`
        Exist   bool   `json:"exist"`
        Created bool   `json:"created"`
}

type UnauthorizedError struct {
        Error  string `json:"error"`
        Status int    `json:"status"`
}

type InvalidRequestError struct {
        Error  string `json:"error"`
        Status int    `json:"status"`
}

type UnsupportedMediaTypeError struct {
        Error  string `json:"error"`
        Status int    `json:"status"`
}

type TooManyRequestsError struct {
        Error  string `json:"error"`
        Status int    `json:"status"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package services

import (
        "fmt"
        "log"
        "polling_websocket/pkg/config"
        "polling_websocket/pkg/domain/models"
        "polling_websocket/pkg/domain/repos"
        "time"
)

type AuthServiceImpl struct {
        jwtGenerator  repos.JWTGenerator
        zitadelClient repos.ZitadelClient
        tokenRepo     repos.TokenRepository
}

func NewAuthService(jwtGenerator repos.JWTGenerator, zitadelClient repos.ZitadelClient, tokenRepo repos.TokenRepository) repos.AuthService <span class="cov0" title="0">{
        return &amp;AuthServiceImpl{
                jwtGenerator:  jwtGenerator,
                zitadelClient: zitadelClient,
                tokenRepo:     tokenRepo,
        }
}</span>

func (s *AuthServiceImpl) GenerateAccessToken() (*string, error) <span class="cov0" title="0">{
        assertionJWT, err := s.jwtGenerator.GenerateActionUserAssertionJWT(time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Cannot generate JWT %v", err)
        }</span>

        <span class="cov0" title="0">accessToken, expiresIn, err := s.zitadelClient.GenerateActionUserAccessToken(assertionJWT)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR | Cannot acces to ACCESS token %v", err)
                return nil, fmt.Errorf("ERROR | Cannot acces to ACCESS token %v", err)
        }</span>

        <span class="cov0" title="0">err = s.tokenRepo.SaveToken(accessToken, &amp;expiresIn)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR | Failed to save token, %v", err)
                return nil, fmt.Errorf("ERROR | Failed to save token, %v", err)
        }</span>

        <span class="cov0" title="0">return accessToken, nil</span>
}

func (s *AuthServiceImpl) GetCachedActionUserAccessToken() *string <span class="cov0" title="0">{
        existingToken, err := s.tokenRepo.GetToken()
        if err != nil &amp;&amp; (err.Error() == "token expired" || err.Error() == "no token found in redis") </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if existingToken == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if config.GetEnv("ROTATE_SERVICE_USER_TOKEN", "n") == "y" </span><span class="cov0" title="0">{
                // to verify
                isValid, err := s.verifyOnlineActionUserToken(existingToken.AccessToken)
                if !isValid || err != nil </span><span class="cov0" title="0">{
                        token, _ := s.GenerateAccessToken()
                        return token
                }</span>
        }
        <span class="cov0" title="0">return existingToken.AccessToken</span>
}

func (s *AuthServiceImpl) verifyCachedActionUserToken(token *string) (isOk bool, err error) <span class="cov0" title="0">{
        cachedAccesToken := s.GetCachedActionUserAccessToken()
        if config.GetEnv("ROTATE_SERVICE_USER_TOKEN", "n") == "y" </span><span class="cov0" title="0">{
                if cachedAccesToken == nil </span><span class="cov0" title="0">{
                        cachedAccesToken, err = s.GenerateAccessToken()
                }</span>
        }

        <span class="cov0" title="0">if cachedAccesToken == nil || err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ERROR | AccessToken cannot be empty")
        }</span>

        <span class="cov0" title="0">if *cachedAccesToken == *token </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return false, fmt.Errorf("ERROR | invalid user token")</span>
}

func (s *AuthServiceImpl) verifyOnlineActionUserToken(token *string) (isValid bool, err error) <span class="cov0" title="0">{
        assertionJWT, err := s.jwtGenerator.GenerateAppInstrospectJWT(time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Cannot generate JWT %v", err)
        }</span> // not validate needs to generate
        <span class="cov0" title="0">isValid, err = s.zitadelClient.ValidateActionUserAccessToken(token, &amp;assertionJWT)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR | Cannot get UserToken %s error: %v", *token, err)
                return false, err
        }</span>
        <span class="cov0" title="0">return isValid, err</span>
}

func (s *AuthServiceImpl) VerifyActionUserToken(token string) (isOk bool, err error) <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ERROR | AccessToken cannot be empty")
        }</span>

        <span class="cov0" title="0">isOk, err = s.verifyCachedActionUserToken(&amp;token)
        if err == nil &amp;&amp; isOk </span><span class="cov0" title="0">{
                return isOk, err
        }</span>

        <span class="cov0" title="0">isOk, err = s.verifyOnlineActionUserToken(&amp;token)
        return isOk, err</span>
}

func (s *AuthServiceImpl) VerifyUserToken(userToken string) (bool, bool) <span class="cov0" title="0">{
        if userToken == "" </span><span class="cov0" title="0">{
                return false, true
        }</span>
        <span class="cov0" title="0">assertionJWT, err := s.jwtGenerator.GenerateAppInstrospectJWT(time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Cannot generate JWT %v", err)
                return false, true
        }</span>

        <span class="cov0" title="0">isValid, expire, err := s.zitadelClient.ValidateUserToken(userToken, assertionJWT)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR | Cannot get UserToken %s error: %v", userToken, err)
                return false, true
        }</span>
        // drift for jwt expire early for 10 minutes
        <span class="cov0" title="0">isExpired := (time.Now().UTC().Unix() - models.TimeDriftForExpire) &gt; expire
        return isValid, isExpired</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package services

import (
        "fmt"
        "polling_websocket/pkg/domain/models"
        "polling_websocket/pkg/domain/repos"
)

type PollingServiceImpl struct {
        redisRepo          repos.PollingRedisRepoInterface
        brokerPollingRepo  repos.PollingBrokerRepository
        brokerCredsRepo    repos.CredentialBrokerRepository
        httpRepo           repos.PollingHTTPRepository
        credentialHTTPRepo repos.CredentialHTTPRepository
}

func NewPollingService(
        repoRedis repos.PollingRedisRepoInterface,
        actionBroker repos.PollingBrokerRepository,
        repoHTTP repos.PollingHTTPRepository,
        credentialRepo repos.CredentialHTTPRepository,
        credentialBroker repos.CredentialBrokerRepository,
) repos.PollingService <span class="cov10" title="4">{
        return &amp;PollingServiceImpl{
                redisRepo:          repoRedis,
                brokerPollingRepo:  actionBroker,
                brokerCredsRepo:    credentialBroker,
                httpRepo:           repoHTTP,
                credentialHTTPRepo: credentialRepo,
        }
}</span>

func (a *PollingServiceImpl) GetContentActionByID(actionID *string, userID *string) (data *string, err error) <span class="cov10" title="4">{
        if actionID == nil || userID == nil </span><span class="cov5" title="2">{
                return nil, fmt.Errorf("cannot by empty")
        }</span>

        <span class="cov5" title="2">data, err = a.getAllContentFromAction(actionID, userID, models.UpdateCommand)
        return data, err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package services

import "fmt"

func (a *PollingServiceImpl) getAllContentFromAction(actionID *string, userID *string, commandType string) (data *string, err error) <span class="cov10" title="2">{
        response, err := a.httpRepo.GetActionByID(actionID, userID, commandType, 1)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("ERROR | failed to fetch action by ID: %w", err)
        }</span>
        // response with len 0 can be posible and its NOT ERROR per se
        <span class="cov1" title="1">if len(response.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">if len(response.Data) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("response contains more than one data entry")
        }</span>

        <span class="cov1" title="1">return &amp;response.Data[0].Data, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package brokerclient

import (
        "encoding/json"
        // "fmt"
        "log"
        "polling_websocket/pkg/common"
        "polling_websocket/pkg/domain/models"
        "time"
)

type CredentialCommand struct {
        Type       string                            `json:"type,omitempty"`
        Credential *models.RequestExchangeCredential `json:"credential"`
        Timestamp  time.Time                         `json:"timestamp,omitempty"`
}

type CredentialKafkaRepository struct {
        client KafkaClient
}

func NewCredentialKafkaRepository(client KafkaClient) *CredentialKafkaRepository <span class="cov9" title="5">{
        return &amp;CredentialKafkaRepository{
                client: client,
        }
}</span>

func (c *CredentialKafkaRepository) UpdateCredential(payload *models.RequestExchangeCredential) (sended bool) <span class="cov6" title="3">{
        if payload == nil </span><span class="cov1" title="1">{
                log.Printf("ERROR | Payload is nil")
                return false
        }</span>
        <span class="cov4" title="2">command := CredentialCommand{
                Credential: payload,
                Type: models.UpdateCommand,
        }
        sended = c.PublishCommand(command, payload.ID)
        return sended</span>
}

func (c *CredentialKafkaRepository) PublishCommand(credentialCommand CredentialCommand, key string) bool <span class="cov7" title="4">{
        command, err := json.Marshal(credentialCommand)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR | Cannot transform to JSON %v", err)
                return false
        }</span>

        <span class="cov7" title="4">for i := 1; i &lt; models.MaxAttempts; i++ </span><span class="cov10" title="6">{
                err = c.client.Produce(models.CredentialTopicName, []byte(key), command)
                if err == nil </span><span class="cov7" title="4">{
                        return true
                }</span>

                <span class="cov4" title="2">waitTime := common.RandomDuration(models.MaxRangeSleepDuration, models.MinRangeSleepDuration, i)
                log.Printf("ERROR | Cannot connect to Broker, attempt %d: %v. Retrying in %v", i, err, waitTime)
                time.Sleep(waitTime)</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package brokerclient

import (
        "log"
        "polling_websocket/pkg/config"

        "github.com/confluentinc/confluent-kafka-go/v2/kafka"
)

type KafkaClient interface {
        Produce(topic string, key []byte, value []byte) error
        Close()
}

type KafkaClientImpl struct {
        producer *kafka.Producer
}

func NewBrokerClient(kafkaConfig config.KafkaConfig) KafkaClient <span class="cov0" title="0">{
        configMap := CreateKafkaConfigMap(kafkaConfig)

        producer, err := kafka.NewProducer(&amp;configMap)
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Cannot create Broker producer %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;KafkaClientImpl{
                producer: producer,
        }</span>
}

func (k *KafkaClientImpl) Produce(topic string, key []byte, value []byte) error <span class="cov0" title="0">{
        message := &amp;kafka.Message{
                TopicPartition: kafka.TopicPartition{Topic: &amp;topic, Partition: kafka.PartitionAny},
                Key:            key,
                Value:          value,
        }

        deliveryChan := make(chan kafka.Event)
        err := k.producer.Produce(message, deliveryChan)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">e := &lt;-deliveryChan
        m := e.(*kafka.Message)

        if m.TopicPartition.Error != nil </span><span class="cov0" title="0">{
                return m.TopicPartition.Error
        }</span>

        <span class="cov0" title="0">close(deliveryChan)
        return err</span>
}

func (k *KafkaClientImpl) Close() <span class="cov0" title="0">{
        k.producer.Close()
}</span>

func CreateKafkaConfigMap(kafkaConfig config.KafkaConfig) kafka.ConfigMap <span class="cov0" title="0">{
        configMap := make(kafka.ConfigMap)
        configMap["bootstrap.servers"] = kafkaConfig.GetServersURI()
        configMap["security.protocol"] = kafkaConfig.GetProtocol()
        configMap["sasl.mechanisms"] = kafkaConfig.GetMechanisms()

        username := kafkaConfig.GetUsername()
        if username != "" </span><span class="cov0" title="0">{
                configMap["sasl.username"] = username
        }</span>

        <span class="cov0" title="0">password := kafkaConfig.GetPassword()
        if password != "" </span><span class="cov0" title="0">{
                configMap["sasl.password"] = password
        }</span>

        <span class="cov0" title="0">timeout := kafkaConfig.GetTimeout()
        if timeout != "" </span><span class="cov0" title="0">{
                configMap["session.timeout.ms"] = timeout
        }</span>

        <span class="cov0" title="0">return configMap</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package brokerclient

import (
        "encoding/json"
        "log"
        "polling_websocket/pkg/common"
        "polling_websocket/pkg/domain/models"
        "time"
)

type PollingKafkaRepository struct {
        client KafkaClient
}

const (
        CommandTypeCreate = "create"
        CommandTypeUpdate = "update"
        CommandTypeDelete = "delete"
        TopicName         = "actions.command"
)

type PollingCommand struct {
        Polling   *models.RequestGoogleAction `json:"actions"`
        Type      string                      `json:"type,omitempty"`
        Timestamp time.Time                   `json:"timestamp,omitempty"`
}

func NewPollingKafkaRepository(client KafkaClient) *PollingKafkaRepository <span class="cov0" title="0">{
        return &amp;PollingKafkaRepository{
                client: client,
        }
}</span>

func (a *PollingKafkaRepository) SendAction(newAction *models.RequestGoogleAction) (sended bool) <span class="cov0" title="0">{
        command := PollingCommand{
                Polling:   newAction,
                Type:      CommandTypeUpdate,
                Timestamp: time.Now(),
        }
        sended = a.PublishCommand(command, newAction.ActionID)
        return sended
}</span>

func (a *PollingKafkaRepository) PublishCommand(payload PollingCommand, key string) bool <span class="cov0" title="0">{
        command, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR | Cannot transform to JSON %v", err)
                return false
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt; models.MaxAttempts; i++ </span><span class="cov0" title="0">{
                err = a.client.Produce(TopicName, []byte(key), command)
                if err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">waitTime := common.RandomDuration(models.MaxRangeSleepDuration, models.MinRangeSleepDuration, i)
                log.Printf("ERROR | Cannot connect to Broker, attempt %d: %v. Retrying in %v", i, err, waitTime)
                time.After(waitTime)</span>
        }

        <span class="cov0" title="0">return false</span>
}

// func (a *PollingKafkaRepository) UpdateCredential(exchangeCredential *models.RequestExchangeCredential) (sended bool) {
//         command := PollingCommand{
//                 Polling: exchangeCredential,
//                 Type:      CommandTypeUpdate,
//                 // Timestamp: time.Now(),
//         }
//         sended = a.PublishCommand(command, newAction.ActionID)
//         return sended
// }
</pre>
		
		<pre class="file" id="file14" style="display: none">package httpclient

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "time"
)

type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
        DoRequest(method, url, authToken string, body interface{}) ([]byte, error)
}

type ClientImpl struct {
        client *http.Client
}

func NewClientImpl(timeout time.Duration) *ClientImpl <span class="cov0" title="0">{
        log.Printf("WARN | Client Http not used Timeout context %v", timeout)
        return &amp;ClientImpl{
                client: &amp;http.Client{
                        Timeout:   http.DefaultClient.Timeout,
                        Transport: http.DefaultTransport,
                },
        }
}</span>

func (c *ClientImpl) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        return c.client.Do(req)
}</span>

func (c *ClientImpl) DoRequest(method, url, authToken string, body interface{}) ([]byte, error) <span class="cov0" title="0">{
        jsonData, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshalling data: %v", err)
        }</span>
        // not used with context
        <span class="cov0" title="0">req, err := http.NewRequest(method, url, NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating request: %v", err)
        }</span>

        <span class="cov0" title="0">c.setHeaders(req, authToken)

        resp, err := c.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error response: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // if resp.StatusCode != http.StatusOK {
        //         bodyBytes, _ := io.ReadAll(resp.Body)
        //         log.Printf("ERROR | failed to response: %d, body: %s", resp.StatusCode, string(bodyBytes))
        //         return nil, fmt.Errorf("error response: %v", err)
        // }

        return io.ReadAll(resp.Body)</span>
}

func (c *ClientImpl) setHeaders(req *http.Request, token string) <span class="cov0" title="0">{
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
}</span>

func NewBuffer(data []byte) io.Reader <span class="cov0" title="0">{
        return bytes.NewBuffer(data)
}</span>

// func getActionsURL(endpoint string) (string, error) {
//         baseURI := fmt.Sprintf("%s%s", config.GetEnv("URI_ACTIONS", "http://localhost:4040"), endpoint)
//         return validateURL(baseURI)
// }

// func validateURL(rawURL string) (string, error) {
//         parsedURL, err := url.ParseRequestURI(rawURL)
//         if err != nil {
//                 return "", fmt.Errorf("invalid URL")
//         }

//         return parsedURL.String(), nil
// }

// package httpclient

// import (
//         // "bytes"
//         // "io"
//         "net/http"
//         "time"
// )

// // type HTTPClient interface {
// //         Do(req *http.Request) (*http.Response, error)
// // }

// // type ClientImpl struct{}

// // func (c *ClientImpl) Do(req *http.Request) (*http.Response, error) {
// //         client := &amp;http.Client{
// //                 Timeout: 15 * time.Second,
// //         }

// //         return client.Do(req)
// // }

// // func NewBuffer(data []byte) io.Reader {
// //         return bytes.NewBuffer(data)
// // }

// type HTTPClient interface {
//         Do(req *http.Request) (*http.Response, error)
//         DoRequest(method, url, authToken string, body interface{}) ([]byte, error)
// }

// type ClientImpl struct {
//         client *http.Client
// }

// func NewClientImpl(timeout time.Duration) *ClientImpl {
//         return &amp;ClientImpl{
//                 client: &amp;http.Client{
//                         Timeout:   http.DefaultClient.Timeout,
//                         Transport: http.DefaultTransport,
//                 },
//         }
// }
</pre>
		
		<pre class="file" id="file15" style="display: none">package httpclient

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/url"
        "polling_websocket/pkg/config"
        "polling_websocket/pkg/domain/models"
)

type CredentialHTTPRepository struct {
        Client          HTTPClient
        DatabaseHTTPURL string
        Token           string
}

func NewCredentialRepository(httpCli HTTPClient, clickhouseConfig config.ClickhouseConfig) *CredentialHTTPRepository <span class="cov10" title="12">{
        return &amp;CredentialHTTPRepository{
                Client:          httpCli,
                DatabaseHTTPURL: clickhouseConfig.GetClickhouseURI(),
                Token:           clickhouseConfig.GetClickhouseToken(),
        }
}</span>

// GetCredentialByID retrieves a credential by its ID from the HTTP repository.
// It constructs a URL with query parameters including token, credential ID, user ID, and limit count,
// then sends a GET request to the constructed URL. The response is expected to be in JSON format.
//
// Parameters:
//   - userID: A pointer to a string representing the user ID.
//   - credentialID: A pointer to a string representing the credential ID.
//   - limitCount: A uint64 representing the limit count.
//
// Returns:
//   - A pointer to models.RequestExchangeCredential containing the credential data if successful.
//   - An error if there is any issue with the request, response, or data decoding.
//
// Errors:
//   - Returns an error if the URL parsing fails.
//   - Returns an error if the HTTP request creation fails.
//   - Returns an error if the HTTP request execution fails.
//   - Returns an error if the response status code is not 200 OK.
//   - Returns an error if the response body cannot be decoded into the expected structure.
//   - Returns an error if the response contains more than one credential data entry.
//
// @Summary Get credential by ID
// @Description Retrieves a credential by its ID from the HTTP repository
// @Tags credentials
// @Accept json
// @Produce json
// @Param user_id query string true "User ID"
// @Param credential_id query string true "Credential ID"
// @Param limit_count query int true "Limit Count"
// @Success 200 {object} models.RequestExchangeCredential
// @Failure 400 {object} models.ErrorResponse
// @Failure 500 {object} models.ErrorResponse
// @Router /credential_id_data.json [get]
func (c *CredentialHTTPRepository) GetCredentialByID(userID *string, credentialID *string, limitCount uint64) (*models.RequestExchangeCredential, error) <span class="cov7" title="6">{
        u, err := url.Parse(c.DatabaseHTTPURL + "/credential_id_data.json")
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="5">q := u.Query()
        q.Set("token", c.Token)
        q.Set("credential_id", *credentialID)
        q.Set("user_id", *userID)
        q.Set("limit_count", fmt.Sprintf("%d", limitCount))
        u.RawQuery = q.Encode()

        req, err := http.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="5">resp, err := c.Client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="4">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("ERROR | response: %d, body: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov4" title="3">var result *models.InfoCredentials

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov3" title="2">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                log.Printf("ERROR | cannot decode body: %s %v", string(bodyBytes), err)
                return nil, fmt.Errorf("ERROR | cannot decode token: %v", err)
        }</span>
        <span class="cov1" title="1">if len(*result.Data) &gt; 1 </span><span class="cov0" title="0">{
                // length cannot be more than 1
                log.Printf("ERROR | duplicated ID: %v", result.Data)
                return nil, fmt.Errorf("ERROR | duplicated id token")
        }</span>
        <span class="cov1" title="1">return &amp;(*result.Data)[0], nil</span>
}

// GetAllCredentials retrieves all credentials for a given user ID with a specified limit count.
// It sends a GET request to the configured database HTTP URL with the provided token, user ID, and limit count as query parameters.
// If the request is successful, it decodes the response body into a slice of RequestExchangeCredential models.
// 
// Parameters:
//   - userID: A pointer to a string representing the user ID for which to retrieve credentials.
//   - limitCount: An unsigned integer representing the maximum number of credentials to retrieve.
//
// Returns:
//   - A pointer to a slice of RequestExchangeCredential models containing the retrieved credentials.
//   - An error if the request fails or the response cannot be decoded.
//
// @Summary Get credential by ID
// @Description Retrieves a credential by its ID from the HTTP repository
// @Tags credentials
// @Accept json
// @Produce json
// @Param user_id query string true "User ID"
// @Param credential_id query string true "Credential ID"
// @Param limit_count query int true "Limit Count"
// @Success 200 {object} models.RequestExchangeCredential
// @Failure 400 {object} models.ErrorResponse
// @Failure 500 {object} models.ErrorResponse
// @Router /credential_id_data.json [get]
func (c *CredentialHTTPRepository) GetAllCredentials(userID *string, limitCount uint64) (*[]models.RequestExchangeCredential, error) <span class="cov7" title="6">{
        u, err := url.Parse(c.DatabaseHTTPURL + "/all_credentials_data.json")
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="5">q := u.Query()
        q.Set("token", c.Token)
        q.Set("user_id", *userID)
        q.Set("limit_count", fmt.Sprintf("%d", limitCount))
        u.RawQuery = q.Encode()

        req, err := http.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="5">resp, err := c.Client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="4">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("ERROR | response: %d, body: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov4" title="3">var result *models.InfoCredentials

        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov1" title="1">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                log.Printf("ERROR | cannot decode body: %s %v", string(bodyBytes), err)
                return nil, fmt.Errorf("ERROR | cannot decode token: %v", err)
        }</span>

        <span class="cov3" title="2">return result.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package httpclient

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/url"
        "polling_websocket/pkg/config"
        "polling_websocket/pkg/domain/models"
)

type PollingHTTPRepository struct {
        DatabaseHTTPURL string
        Token           string
        Client          HTTPClient
}

func NewPollingClientHTTP(client HTTPClient, clickhouseConfig config.ClickhouseConfig) *PollingHTTPRepository <span class="cov0" title="0">{
        return &amp;PollingHTTPRepository{
                Client:          client,
                DatabaseHTTPURL: clickhouseConfig.GetClickhouseURI(),
                Token:           clickhouseConfig.GetClickhouseToken(),
        }
}</span>

// GetActionByID retrieves action details by action ID from the polling HTTP repository.
// It constructs a URL with the provided parameters, sends a GET request, and decodes the response.
//
// Parameters:
//   - actionID: Pointer to the action ID string.
//   - userID: Pointer to the user ID string.
//   - commandType: Type of the command as a string.
//   - limitCount: Limit count as an unsigned 64-bit integer.
//
// Returns:
//   - data: Pointer to the ResponsePollingActionID model containing the action details.
//   - err: Error if any occurred during the process.
//
// Errors:
//   - Returns an error if the URL cannot be parsed.
//   - Returns an error if the HTTP request cannot be generated.
//   - Returns an error if the HTTP request fails.
//   - Returns an error if the response status is not OK (200).
//   - Returns an error if the response body is nil or cannot be decoded.
//
// @Summary Get action details by action ID
// @Description Retrieves action details by action ID from the polling HTTP repository
// @Tags actions
// @Accept json
// @Produce json
// @Param action_id query string true "Action ID"
// @Param user_id query string true "User ID"
// @Param command_type query string true "Command Type"
// @Param limit_count query int true "Limit Count"
// @Success 200 {object} models.ResponsePollingActionID
// @Failure 400 {object} models.ErrorResponse
// @Failure 500 {object} models.ErrorResponse
// @Router /action_workflow_data.json [get]
func (a *PollingHTTPRepository) GetActionByID(actionID *string, userID *string, commandType string, limitCount uint64) (data *models.ResponsePollingActionID, err error) <span class="cov10" title="5">{
        u, err := url.Parse(a.DatabaseHTTPURL + "/action_workflow_data.json")
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("ERROR | polling httpclient cannot parse url %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="4">q := u.Query()
        q.Set("token", a.Token)
        q.Set("action_id", *actionID)
        q.Set("user_id", *userID)
        q.Set("command_type", commandType)
        q.Set("limit_count", fmt.Sprintf("%d", limitCount))
        u.RawQuery = q.Encode()
        req, err := http.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR | polling httpclient cannot generate request %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="4">resp, err := a.Client.Do(req)
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("ERROR | polling httpclient not response %v", err)
                return nil, err
        }</span>
        <span class="cov7" title="3">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("ERROR | response: %d, body: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov4" title="2">if resp.Body == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ERROR | response body is nil")
        }</span>

        <span class="cov4" title="2">var result *models.ResponsePollingActionID
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov1" title="1">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                log.Printf("ERROR | cannot decode body: %s %v", string(bodyBytes), err)
                return nil, fmt.Errorf("ERROR | cannot decode token: %v", err)
        }</span>
        <span class="cov1" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package httpclient

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "polling_websocket/pkg/domain/models"
        "polling_websocket/pkg/infra/tokenrepo"
        "strings"
        "time"
)

type ZitadelClient struct {
        apiURL     string
        ClientHTTP HTTPClient
        userID     string
        privateKey []byte
        keyID      string
        clientID   string
        projectID  string
}

func NewZitadelClient(apiURL, userID, privateKey, keyID, projectID, clientID string) *ZitadelClient <span class="cov0" title="0">{
        return &amp;ZitadelClient{
                apiURL:     apiURL,
                ClientHTTP: NewClientImpl(models.TimeoutRequest),
                userID:     userID,
                privateKey: []byte(privateKey),
                keyID:      keyID,
                projectID:  projectID,
                clientID:   clientID,
        }
}</span>

func (z *ZitadelClient) SetHTTPClient(client HTTPClient) <span class="cov0" title="0">{
        z.ClientHTTP = client
}</span>

func (z *ZitadelClient) GenerateActionUserAccessToken(jwt string) (*string, time.Duration, error) <span class="cov0" title="0">{
        if jwt == "" </span><span class="cov0" title="0">{
                return nil, models.OneDay, fmt.Errorf("ERROR | token empty")
        }</span>
        <span class="cov0" title="0">data := fmt.Sprintf(`grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&amp;scope='openid profile urn:zitadel:iam:org:project:id:%s:aud'&amp;assertion=%s`, z.projectID, jwt)
        req, err := http.NewRequest("POST", z.apiURL+"/oauth/v2/token", bytes.NewBufferString(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, models.OneDay, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := z.ClientHTTP.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, models.OneDay, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return nil, models.OneDay, fmt.Errorf("ERROR | failed to get access token response: %d, body: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">var result tokenrepo.Token
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, models.OneDay, fmt.Errorf("ERROR | cannot get decode token: %v", err)
        }</span>

        <span class="cov0" title="0">return result.AccessToken, result.ExpiresIn, nil</span>
}

func (z *ZitadelClient) ValidateUserToken(userToken, jwtToken string) (bool, int64, error) <span class="cov0" title="0">{
        data := fmt.Sprintf("client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&amp;client_assertion=%s&amp;token=%s", jwtToken, userToken)
        req, err := http.NewRequest("POST", z.apiURL+"/oauth/v2/introspect", strings.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, fmt.Errorf("ERROR | cannot generate sol: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        resp, err := z.ClientHTTP.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, fmt.Errorf("ERROR | cannot send request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return false, 0, fmt.Errorf("ERROR | response: %d, body: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">var result models.VerifyTokenUser
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return false, 0, fmt.Errorf("ERROR | cannot decode token: %v body msg: %s", err, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">return *result.Active, *result.Exp, nil</span>
}

func (z *ZitadelClient) ValidateActionUserAccessToken(actionUserToken, jwtToken *string) (bool, error) <span class="cov0" title="0">{
        data := fmt.Sprintf("client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&amp;client_assertion=%s&amp;token=%s", *jwtToken, *actionUserToken)
        req, err := http.NewRequest("POST", z.apiURL+"/oauth/v2/introspect", strings.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ERROR | cannot create HTTP newRequest: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        resp, err := z.ClientHTTP.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ERROR | cannot send request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return false, fmt.Errorf("ERROR | response: %d, body: %s", resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">var result models.VerifyTokenUser
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return false, fmt.Errorf("ERROR | cannot decode token: %v body msg: %s", err, string(bodyBytes))
        }</span>

        <span class="cov0" title="0">return *result.Active, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package redisclient

import (
        "fmt"
        "log"
        "polling_websocket/pkg/common"
        "polling_websocket/pkg/domain/models"
        "time"
)

const (
        PollingGlobalAll = "polling:all"
        EmptyValue       = "_"
)

type PollingService interface {
}

type PollingRepository struct {
        redisClient *RedisClient
}

func NewPollingRepository(redisClient *RedisClient) *PollingRepository <span class="cov0" title="0">{
        return &amp;PollingRepository{redisClient: redisClient}
}</span>

func (a *PollingRepository) GetPollingGlobalAll() string <span class="cov0" title="0">{
        return PollingGlobalAll
}</span>

func (a *PollingRepository) ValidateActionGlobalUUID(uuid *string) (bool, error) <span class="cov0" title="0">{
        exists, err := a.redisClient.Hexists(PollingGlobalAll, *uuid)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR | Redis HExists error: %v", err)
                return true, err
        }</span>
        <span class="cov0" title="0">return exists, err</span>
}

func (a *PollingRepository) AcquireLock(key, value string, expiration time.Duration) (locked bool, err error) <span class="cov0" title="0">{
        for i := 1; i &lt; models.MaxAttempts; i++ </span><span class="cov0" title="0">{
                locked, err = a.redisClient.AcquireLock(key, value, expiration)
                if err == nil </span><span class="cov0" title="0">{
                        return locked, err
                }</span>

                <span class="cov0" title="0">waitTime := common.RandomDuration(models.MaxRangeSleepDuration, models.MinRangeSleepDuration, i)
                log.Printf("ERROR | Cannot connect to redis for key %s, attempt %d: %v. Retrying in %v", key, i, err, waitTime)
                time.Sleep(waitTime)</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("ERROR | Cannot create lock for key %s. More than 10 intents", key)</span>
}

func (a *PollingRepository) RemoveLock(key string) bool <span class="cov0" title="0">{
        for i := 1; i &lt; models.MaxAttempts; i++ </span><span class="cov0" title="0">{
                countRemoved, err := a.redisClient.RemoveLock(key)
                if countRemoved == 0 </span><span class="cov0" title="0">{
                        log.Printf("WARNING | Key already removed, previuous process take more than 20 seconds")
                }</span>
                <span class="cov0" title="0">if err == nil &amp;&amp; countRemoved &lt;= 1 </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">waitTime := common.RandomDuration(models.MaxRangeSleepDuration, models.MinRangeSleepDuration, i)
                log.Printf("ERROR | Cannot connect to redis for key %s, attempt %d: %v. Retrying in %v", key, i, err, waitTime)
                time.Sleep(waitTime)</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (a *PollingRepository) SetNX(hashKey, actionID string, expiration time.Duration) (bool, error) <span class="cov0" title="0">{
        inserted, err := a.redisClient.SetEx(hashKey, actionID, expiration)
        return inserted, err
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package redisclient

import (
        "context"
        "fmt"
        "log"
        "polling_websocket/pkg/config"

        // "polling_websocket/pkg/domain/models"
        "time"

        "github.com/go-redis/redis/v8"
)

type RedisClient struct {
        Client *redis.Client
        Ctx    context.Context
}

var ErrActionExists = fmt.Errorf("action already exists")

const (
        operationSET    = "set"
        operationREMOVE = "remove"
        operationUPDATE = "update"
)

func NewRedisClient() *RedisClient <span class="cov0" title="0">{
        opt, err := redis.ParseURL(config.GetEnv("VAULT_URI", ""))
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Not connected to Redis. Cannot parse Redis URI %s", config.GetEnv("VAULT_URI", ""))
        }</span>

        <span class="cov0" title="0">rdb := redis.NewClient(opt)
        // _, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        _, cancel := context.WithCancel(context.Background())
        defer cancel()

        if rdb.Ping(context.Background()).Val() != "PONG" </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Server Redis not pong")
        }</span>

        <span class="cov0" title="0">return &amp;RedisClient{
                Client: rdb,
                Ctx:    context.Background(),
        }</span>
}

func (r *RedisClient) Set(key string, value interface{}) error <span class="cov0" title="0">{
        return r.Client.Set(r.Ctx, key, value, 0).Err()
}</span>

func (r *RedisClient) SetEx(key string, value interface{}, expiration time.Duration) (bool, error) <span class="cov0" title="0">{
        result, err := r.Client.Set(r.Ctx, key, value, expiration).Result()
        return result == "OK", err
}</span>

func (r *RedisClient) Hset(key string, field string, values interface{}) bool <span class="cov0" title="0">{
        inserted := r.Client.HSet(r.Ctx, key, field, values).Val()
        return inserted != 0
}</span>

func (r *RedisClient) Hget(key string, field string) error <span class="cov0" title="0">{
        return r.Client.HGet(r.Ctx, key, field).Err()
}</span>

func (r *RedisClient) Hexists(key string, field string) (bool, error) <span class="cov0" title="0">{
        return r.Client.HExists(r.Ctx, key, field).Result()
}</span>

func (r *RedisClient) Exists(key string) (int64, error) <span class="cov0" title="0">{
        return r.Client.Exists(r.Ctx, key).Result()
}</span>

func (r *RedisClient) Get(key string) (string, error) <span class="cov0" title="0">{
        result, err := r.Client.Get(r.Ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// func (r *RedisClient) WatchWorkflow(workflow *models.Workflow, operation string) error {
//         return r.Client.Watch(r.Ctx, func(tx *redis.Tx) error {
//                 return r.CheckAndModifyWorkflow(r.Ctx, tx, workflow, operation)
//         })
// }

// func (r *RedisClient) CheckAndModifyWorkflow(ctx context.Context, tx *redis.Tx, workflow *models.Workflow, operation string) error {
//         uuidExists, err := tx.HExists(ctx, "workflows:all", workflow.UUID).Result()
//         if err != nil {
//                 log.Printf("ERROR | checking UUID existence: %v", err)
//                 return fmt.Errorf(models.UUIDCannotGenerate)
//         }

//         // not necessary
//         // nameExists, err := tx.HExists(ctx, fmt.Sprintf("users:%s", workflow.Sub), workflow.WorkflowName).Result()
//         // if err != nil {
//         //         log.Printf("ERROR | checking workflow name existence: %v", err)
//         //         return fmt.Errorf(models.WorkflowNameCannotGenerate)
//         // }

//         switch operation {
//         case operationSET:
//                 if uuidExists {
//                         return fmt.Errorf(models.UUIDExist)
//                 }
//                 // if nameExists {
//                 //         return fmt.Errorf(models.WorkflowNameExist)
//                 // }
//                 return r.setWorkflow(ctx, tx, workflow)
//         case operationREMOVE:
//                 // if !uuidExists {
//                 //         return fmt.Errorf(models.UUIDNotExist)
//                 // }
//                 // if !nameExists {
//                 //         return fmt.Errorf(models.WorkflowNameNotExist)
//                 // }
//                 return r.removeWorkflow(ctx, tx, workflow)
//         case operationUPDATE:
//                 return r.setWorkflow(ctx, tx, nil)
//         default:
//                 return fmt.Errorf("unknown operation: %s", operation)
//         }
// }

// func (r *RedisClient) setWorkflow(ctx context.Context, tx *redis.Tx, workflow *models.Workflow) error {
//         _, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
//                 pipe.HSet(ctx, fmt.Sprintf("users:%s", workflow.UserID), workflow.Name, workflow.UUID)
//                 pipe.HSet(ctx, "workflows:all", workflow.UUID, workflow.UserID)
//                 return nil
//         })
//         return err
// }

// func (r *RedisClient) updateWorkflow(ctx context.Context, tx *redis.Tx, workflow *models.Workflow) error {
//         _, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
//                 pipe.HSet(ctx, fmt.Sprintf("users:%s", workflow.UserID), workflow.Name, workflow.UUID)
//                 pipe.HSet(ctx, "workflows:all", workflow.UUID, workflow.UserID)
//                 return nil
//         })
//         return err
// }

// func (r *RedisClient) removeWorkflow(ctx context.Context, tx *redis.Tx, workflow *models.Workflow) error {
//         _, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
//                 pipe.HDel(ctx, fmt.Sprintf("users:%s", workflow.UserID), workflow.Name)
//                 pipe.HDel(ctx, "workflows:all", workflow.UUID)
//                 return nil
//         })
//         return err
// }

// func (r *RedisClient) SetWorkflow(workflow *models.Workflow) error {
//         return r.WatchWorkflow(workflow, operationSET)
// }

// func (r *RedisClient) UpdateWorkflow(workflow *models.Workflow) error {
//         return r.WatchWorkflow(workflow, operationUPDATE)
// }

// func (r *RedisClient) RemoveWorkflow(workflow *models.Workflow) error {
//         return r.WatchWorkflow(workflow, operationREMOVE)
// }

// func (r *RedisClient) WatchUser(user *models.SyncUserRequest, lockKey, userKey string, duration time.Duration) (inserted bool, lockExists bool, userExists bool, err error) {
//         err = r.Client.Watch(r.Ctx, func(tx *redis.Tx) error {
//                 lockExists, err = checkLockExists(r.Ctx, tx, lockKey, user.Sub) // Not necessary
//                 if err != nil || lockExists {
//                         return err
//                 }

//                 userExists, err = checkUserExists(r.Ctx, tx, userKey, user.Sub)
//                 if err != nil || userExists {
//                         return err
//                 }

//                 inserted, err = executePipeline(r.Ctx, tx, lockKey, userKey, duration, user.Sub)
//                 return err
//         }, lockKey)

//                return inserted, lockExists, userExists, err
//        }
//
// locked
func checkLockExists(ctx context.Context, tx *redis.Tx, lockKey, userSub string) (bool, error) <span class="cov0" title="0">{
        lockExistsVal, err := tx.Exists(ctx, lockKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ERROR | Failed to check lock existence: %v", err)
        }</span>
        <span class="cov0" title="0">if lockExistsVal == 1 </span><span class="cov0" title="0">{
                return true, fmt.Errorf("ERROR | Lock already exists for user %s", userSub)
        }</span>
        <span class="cov0" title="0">return false, nil</span>
}

// func checkUserExists(ctx context.Context, tx *redis.Tx, userKey, userSub string) (bool, error) {
//         userExistsVal, err := tx.Exists(ctx, userKey).Result()
//         if err != nil {
//                 return false, fmt.Errorf("ERROR | Failed to check user existence: %v", err)
//         }
//         if userExistsVal == 1 {
//                 return true, fmt.Errorf("ERROR | User %s already exists", userSub)
//         }
//         return false, nil
// }

// func executePipeline(ctx context.Context, tx *redis.Tx, lockKey, userKey string, duration time.Duration, userSub string) (bool, error) {
//         cmds, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {
//                 pipe.SetNX(ctx, lockKey, "_", duration)
//                 pipe.HSet(ctx, userKey, "_", "_") // dummy value
//                 return nil
//         })
//         if err != nil {
//                 return false, fmt.Errorf("ERROR | Transaction failed: %v", err)
//         }

//         for i, cmd := range cmds {
//                 if cmd.Err() != nil {
//                         return false, fmt.Errorf("ERROR | Command failed: %v for user %s", cmd.Err(), userSub)
//                 }

//                 switch i {
//                 case 0: // SetNX command
//                         lockSet, err := cmd.(*redis.BoolCmd).Result()
//                         if err != nil {
//                                 return false, fmt.Errorf("ERROR | Failed to get SetNX result: %v", err)
//                         }
//                         if !lockSet {
//                                 return false, fmt.Errorf("ERROR | Lock already exists for user %s", userSub)
//                         }
//                 case 1: // HSet command
//                         fieldsCreated, err := cmd.(*redis.IntCmd).Result()
//                         if err != nil {
//                                 return false, fmt.Errorf("ERROR | Failed to get HSet result: %v", err)
//                         }
//                         if fieldsCreated == 0 {
//                                 return false, fmt.Errorf("ERROR | User %s already exists", userSub)
//                         }
//                 }
//         }

//         return true, nil
// }

// REDO
func (r *RedisClient) WatchToken(data string, key string, expires time.Duration) error <span class="cov0" title="0">{
        err := r.Client.Watch(r.Ctx, func(tx *redis.Tx) error </span><span class="cov0" title="0">{
                _, err := tx.TxPipelined(r.Ctx, func(pipe redis.Pipeliner) error </span><span class="cov0" title="0">{
                        err := pipe.SetNX(r.Ctx, key, data, expires).Err()
                        return err
                }</span>)
                <span class="cov0" title="0">return err</span>
        }, key)

        <span class="cov0" title="0">return err</span>
}

func (r *RedisClient) AcquireLock(key, value string, expiration time.Duration) (bool, error) <span class="cov0" title="0">{
        return r.Client.SetNX(r.Ctx, key, value, expiration).Result()
}</span>

func (r *RedisClient) RemoveLock(key string) (int64, error) <span class="cov0" title="0">{
        result, err := r.Client.Del(r.Ctx, key).Result()
        return result, err
}</span>

func (r *RedisClient) Hdel(key string, field string) (int64, error) <span class="cov0" title="0">{
        result, err := r.Client.HDel(r.Ctx, key, field).Result()
        return result, err
}</span>

func (r *RedisClient) WatchAndExecute(ctx context.Context, keys []string, txFunc func(tx *redis.Tx) error) error <span class="cov0" title="0">{
        return r.Client.Watch(ctx, txFunc, keys...)
}</span>

func (r *RedisClient) ExecuteTransaction(ctx context.Context, keys []string, txFunc func(tx *redis.Tx) error) error <span class="cov0" title="0">{
        return r.WatchAndExecute(ctx, keys, txFunc)
}</span>

// func (r *RedisClient) SetAction(ctx context.Context, newAction *models.RequestGoogleAction, txf func(tx *redis.Tx) error) (inserted bool, existed bool, err error) {
//         if newAction.ActionID == "" {
//                 return false, false, fmt.Errorf("ActionID is required")
//         }
//         if newAction.RequestID == "" {
//                 return false, false, fmt.Errorf("RequestID is required")
//         }
//         lockKey := fmt.Sprintf("lock:%s", newAction.ActionID)
//         // key := "actions:all"
//         // field := newAction.ActionID
//         // value := newAction.Sub

//         err = r.ExecuteTransaction(ctx, []string{ActionsGlobalAll, lockKey}, txf)
//         if err != nil {
//                 if err == redis.TxFailedErr {
//                         log.Println("Concurrent transaction error detected.")
//                         return false, true, nil
//                 }
//                 log.Printf("Error in Redis transaction: %v", err)
//                 return false, false, err
//         }

//         return true, false, nil
// }

func (r *RedisClient) HSetNX(key string, field *string, value string) (bool, error) <span class="cov0" title="0">{
        return r.Client.HSetNX(r.Ctx, key, *field, value).Result()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package tokenrepo

import (
        "encoding/json"
        "fmt"
        "log"

        "polling_websocket/pkg/config"
        "polling_websocket/pkg/domain/models"
        "polling_websocket/pkg/infra/redisclient"
        "sync"
        "time"
)

type Token struct {
        ObtainedAt  time.Time     `json:"obtained_at"`
        AccessToken *string       `json:"access_token"`
        TokenType   string        `json:"token_type"`
        ExpiresIn   time.Duration `json:"expires_in"`
}

type TokenRepository struct {
        mu          sync.RWMutex
        redisClient *redisclient.RedisClient
        key         string
        token       *Token
}

func NewTokenRepository(redisClient *redisclient.RedisClient) *TokenRepository <span class="cov0" title="0">{
        return &amp;TokenRepository{
                redisClient: redisClient,
                key:         "serviceuser_backend:token",
        }
}</span>

func (r *TokenRepository) GetToken() (*Token, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        if r.token != nil </span><span class="cov0" title="0">{
                if r.isExpired(*r.token) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("token expired")
                }</span>
                <span class="cov0" title="0">return r.token, nil</span>
        }

        <span class="cov0" title="0">data, err := r.redisClient.Get(r.key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if data == "" </span><span class="cov0" title="0">{ // Not exist key in redis
                return nil, fmt.Errorf("no token found in redis")
        }</span>

        <span class="cov0" title="0">var token Token
        err = json.Unmarshal([]byte(data), &amp;token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if r.isExpired(token) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token expired")
        }</span>

        <span class="cov0" title="0">r.token = &amp;token
        return r.token, nil</span>
}

func (r *TokenRepository) isExpired(token Token) bool <span class="cov0" title="0">{
        if config.GetEnv("ROTATE_SERVICE_USER_TOKEN", "n") == "y" </span><span class="cov0" title="0">{
                if time.Now().UTC().After(token.ObtainedAt.Add(token.ExpiresIn * time.Second)) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (r *TokenRepository) SaveToken(accessToken *string, expiresIn *time.Duration) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()

        token := Token{
                AccessToken: accessToken,
                ExpiresIn:   *expiresIn - models.SaveOffset, // -10 seconds
                ObtainedAt:  time.Now().UTC(),
        }

        data, err := json.Marshal(token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = r.redisClient.WatchToken(string(data), r.key, (token.ExpiresIn)*time.Second)
        if err == nil </span><span class="cov0" title="0">{
                r.token = &amp;token
                return nil
        }</span>

        <span class="cov0" title="0">log.Printf("ERROR | Failed to save token, %v", err)
        return err</span>
}

func (r *TokenRepository) SetToken(token *Token) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.token = token
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package vaults

import (
        "log"
        "os"

        "github.com/joho/godotenv"
)

func GetEnvsFromVault() <span class="cov0" title="0">{
        envValues := GetAllEnvsFromRedis()
        envsMaped := serializeEnvs(envValues)
        SetEnvs(envsMaped)
}</span>

func serializeEnvs(envStr string) map[string]string <span class="cov0" title="0">{
        envMap, err := godotenv.Unmarshal(envStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Panic("ERROR | Cannot serialize string from Env")
        }</span>
        <span class="cov0" title="0">return envMap</span>
}

func SetEnvs(envsMapped map[string]string) <span class="cov0" title="0">{
        for key, value := range envsMapped </span><span class="cov0" title="0">{
                os.Setenv(key, value)
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package vaults

import (
        "context"
        "log"
        "os"

        "github.com/go-redis/redis/v8"
)

// redis with ctx with timeout ?
var ctx = context.Background()

const (
        PONG = "PONG"
)

func GetAllEnvsFromRedis() string <span class="cov0" title="0">{
        uriVault := os.Getenv("VAULT_URI")
        vaultKeyFrontendEnvs := os.Getenv("VAULT_KEY_BACKEND_ENVS")

        if uriVault == "" </span><span class="cov0" title="0">{
                log.Print("ERROR | Cannot load initial VAULT_URI")
                return ""
        }</span>
        <span class="cov0" title="0">if vaultKeyFrontendEnvs == "" </span><span class="cov0" title="0">{
                vaultKeyFrontendEnvs = "vault_backend_reipaz"
        }</span>
        <span class="cov0" title="0">opt, err := redis.ParseURL(uriVault)
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Cannot parse uri %s error: %v", uriVault, err)
        }</span>
        <span class="cov0" title="0">redisClient := redis.NewClient(opt)
        defer redisClient.Close()

        err = pingRedis(ctx, redisClient)
        if err != nil </span><span class="cov0" title="0">{
                log.Panic("ERROR | Not possible to ping REDIS vault")
        }</span>

        <span class="cov0" title="0">envsStr, err := getEnvsFromRedis(ctx, redisClient, vaultKeyFrontendEnvs)
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Cannot load VAULT_KEY_FRONTEND_ENVS %v", err)
        }</span>
        <span class="cov0" title="0">return envsStr</span>
}

func pingRedis(ctx context.Context, client *redis.Client) error <span class="cov0" title="0">{
        status, err := client.Ping(ctx).Result()
        if err != nil || status != "PONG" </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Not possible to ping REDIS vault error: %v", err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func getEnvsFromRedis(ctx context.Context, client *redis.Client, key string) (string, error) <span class="cov0" title="0">{
        envsStr, err := client.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("ERROR | Cannot load VAULT_KEY_FRONTEND_ENVS %v", err)
        }</span>
        <span class="cov0" title="0">return envsStr, err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
